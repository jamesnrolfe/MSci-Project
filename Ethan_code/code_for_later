function plot_figure_9()
    # --- Simulation Parameters ---
    N_range = 10:2:100          # System sizes from 10 to 100
    num_sweeps = 30             # Sweeps for DMRG
    max_bond_dim_limit = 250    # Generous bond dimension limit for DMRG
    cutoff = 1E-10
    
    # Parameters for the inhomogeneous graph
    σ = 0.002
    μ = 1.0
    num_graphs_avg = 10         # Average over 10 random graphs per data point

    # --- Data Storage ---
    avg_bond_dims = Float64[]
    std_dev_bond_dims = Float64[] # For error bars

    println("Starting DMRG calculation for Figure 9 (σ = $σ)...")
    # --- Main Loop ---
    for N in N_range
        bond_dims_for_avg = Float64[]
        
        # Loop to average over multiple random graphs
        for i in 1:num_graphs_avg
            # 1. Set up the system with a new random graph each time
            ψ₀, sites = create_MPS(N)
            adj_mat = create_weighted_adj_mat(N, σ; μ=μ)

            # 2. Create the Hamiltonian MPO with the report's parameters
            H_mpo = create_weighted_xxz_mpo(N, adj_mat, sites; J=-0.5, Δ=0.5)

            # 3. Prepare and run DMRG
            sweeps = Sweeps(num_sweeps)
            setmaxdim!(sweeps, max_bond_dim_limit)
            setcutoff!(sweeps, cutoff)

            _, ψ_gs = dmrg(H_mpo, ψ₀, sweeps; outputlevel=0)
            
            # 4. Store the max bond dimension for this run
            push!(bond_dims_for_avg, maxlinkdim(ψ_gs))
        end

        # 5. Calculate the average and standard deviation for this N
        avg_dim = mean(bond_dims_for_avg)
        std_dev = std(bond_dims_for_avg)
        
        push!(avg_bond_dims, avg_dim)
        push!(std_dev_bond_dims, std_dev)

        println("Completed N = $N. Avg Bond Dim = $(round(avg_dim, digits=2)) ± $(round(std_dev, digits=2))")
    end
    println("...calculations finished.")

    # --- Plotting ---
    plt = plot(
        title="Saturated Bond Dimension for an Average Graph with N Nodes",
        xlabel="Number of Nodes",
        ylabel="Average Bond Dimension Required",
        legend=false,
        gridalpha=0.3,
        framestyle=:box
    )

    plot!(plt, N_range, avg_bond_dims,
        yerror=std_dev_bond_dims, # Add error bars
        lw=2,
        marker=:circle,
        markersize=4,
        markerstrokecolor=:auto,
        markercolor=:coral,
        linecolor=:deepskyblue
    )
    
    return plt
end

# --- Run the function to generate the plot ---
# Make sure you have defined the helper functions from the previous responses first!
# (create_MPS, create_weighted_adj_mat, create_weighted_xxz_mpo)

# plt = plot_figure_9();
# display(plt)

















using ITensors, ITensorMPS
using Plots
using Random
using Statistics
using LinearAlgebra

"""
Creates a random MPS for a spin-1/2 chain of length L, conserving total Sz.
"""
function create_MPS(L::Int)
    sites = siteinds("S=1/2", L; conserve_qns=true)
    initial_state = [isodd(i) ? "Up" : "Dn" for i in 1:L]
    ψ₀ = randomMPS(sites, initial_state)
    return ψ₀, sites
end

"""
Creates a weighted adjacency matrix for a completely connected graph.
"""
function create_weighted_adj_mat(N::Int, σ::Float64; μ::Float64=1.0)
    if σ == 0.0
        A = ones(Float64, N, N)
        A -= Matrix{Float64}(I, N, N)
        return A
    end
    A = zeros(Float64, N, N)
    for i in 1:N, j in (i+1):N
        weight = μ + σ * randn()
        A[i, j] = A[j, i] = weight
    end
    return A
end

"""
Creates the MPO for the XXZ Hamiltonian on a graph with weighted interactions.
"""
function create_weighted_xxz_mpo(N::Int, adj_mat, sites; J::Float64, Δ::Float64)
    ampo = OpSum()
    for i in 1:N-1
        for j in i+1:N
            coupling_strength = adj_mat[i, j]
            if coupling_strength != 0.0
                ampo += coupling_strength * (J / 2), "S+", i, "S-", j
                ampo += coupling_strength * (J / 2), "S-", i, "S+", j
                ampo += coupling_strength * (J * Δ), "Sz", i, "Sz", j
            end
        end
    end
    return MPO(ampo, sites)
end

"""
Main function to calculate and plot the data for Figure 10.
"""
function plot_figure_10()
    # --- Simulation Parameters ---
    N_range = 10:2:100
    sigma_values = [0.0, 0.001, 0.002]
    num_graphs_avg = 10
    num_sweeps = 30
    max_bond_dim_limit = 250
    cutoff = 1E-10
    μ = 1.0

    # --- Data Storage ---
    results = Dict(σ => (avg=Float64[], err=Float64[]) for σ in sigma_values)

    println("Starting DMRG calculation for Figure 10...")
    # --- Main Loop ---
    for N in N_range
        println("Running N = $N...")
        for σ in sigma_values
            bond_dims_for_avg = Float64[]
            for _ in 1:num_graphs_avg
                ψ₀, sites = create_MPS(N)
                adj_mat = create_weighted_adj_mat(N, σ; μ=μ)
                H_mpo = create_weighted_xxz_mpo(N, adj_mat, sites; J=-0.5, Δ=0.5)

                sweeps = Sweeps(num_sweeps)
                setmaxdim!(sweeps, max_bond_dim_limit)
                setcutoff!(sweeps, cutoff)

                _, ψ_gs = dmrg(H_mpo, ψ₀, sweeps; outputlevel=0)
                push!(bond_dims_for_avg, maxlinkdim(ψ_gs))
            end

            avg_dim = mean(bond_dims_for_avg)
            std_dev = std(bond_dims_for_avg)
            
            push!(results[σ].avg, avg_dim)
            push!(results[σ].err, std_dev)
        end
    end
    println("...calculations finished.")

    # --- Plotting ---
    plt = plot(
        title="Saturated Bond Dimension for an Average Graph with N Nodes",
        xlabel="Number of Nodes",
        ylabel="Average Bond Dimension Required",
        legend=:topleft,
        gridalpha=0.3,
        framestyle=:box
    )

    colors = Dict(0.0 => :gold, 0.001 => :darkviolet, 0.002 => :firebrick)

    for σ in sigma_values
        plot!(plt, N_range, results[σ].avg,
            yerror=results[σ].err,
            label="σ = $σ",
            lw=1.5,
            marker=:circle,
            markersize=3,
            color=colors[σ]
        )
    end
    
    return plt
end

# --- Run the function to generate the plot ---
# plt = plot_figure_10();
# display(plt)